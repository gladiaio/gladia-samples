<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://unpkg.com/@gladiaio/sdk@0.5.1"></script>
    <title>Gladia - Live from microphone</title>

    <!-- We are using a 3rd party library to record audio as WAV on every browser. -->
    <!-- Each browser uses its own audio encoding and some of them are not compatible. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/RecordRTC/5.6.2/RecordRTC.js"></script>

    <style>
      body {
        margin: 1rem;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      form > div {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      form,
      #result {
        box-sizing: border-box;
        max-width: 500px;
        margin: 0 auto;
      }

      #result {
        margin-top: 1rem;
        border-top: 1px solid #333;
        padding-top: 1rem;
        text-align: justify;
      }
    </style>
  </head>
  <body>
    <form id="form">
      <div>
        <label for="gladia_key">Gladia API key</label>
        <input
          id="gladia_key"
          name="gladia_key"
          type="text"
          placeholder="Gladia API key"
          required
        />
      </div>
      <div>
        <label for="input_device">Audio input device</label>
        <select
          id="input_device"
          name="input_device"
          required
          disabled
        ></select>
      </div>
      <button type="submit">Start recording</button>
      <button type="button" style="color: white" disabled>
        Stop recording
      </button>
    </form>

    <div id="result" style="display: none">
      <div id="finals"></div>
      <div style="color: red" id="partials"></div>
    </div>

    <script>
      const SAMPLE_RATE = 16000;

      // Initialize the audio input devices
      async function listAudioDevices() {
        /** @type {HTMLSelectElement} */
        const inputDeviceSelect = document.querySelector(
          'select[name="input_device"]',
        );

        if (window.location.protocol === 'file:') {
          const audioDevices = await navigator.mediaDevices
            .enumerateDevices()
            .then((devices) => devices.filter((d) => d.kind === 'audioinput'));
          if (!audioDevices.length) {
            window.alert('No audio input device found');
            return;
          }

          console.log(
            'Cannot list audio input devices since you are running the file locally. We will use your default audio input.',
          );
          const option = document.createElement('option');
          option.textContent = 'Default';
          option.value = '';
          inputDeviceSelect.appendChild(option);
          inputDeviceSelect.value = '';
          return;
        }

        // Ask the permissions to the user
        const media = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });

        const audioDevices = await navigator.mediaDevices
          .enumerateDevices()
          .then((devices) =>
            devices.filter((d) => d.kind === 'audioinput' && d.deviceId),
          );

        // Stop all the tracks now that we have the user permission
        media.getTracks().forEach((track) => track.stop());

        if (!audioDevices.length) {
          window.alert('No audio input device found');
          return;
        }

        inputDeviceSelect.textContent = '';
        audioDevices.forEach((device) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label ?? 'Default';
          inputDeviceSelect.appendChild(option);
        });
        inputDeviceSelect.value = audioDevices[0]?.deviceId ?? '';
        inputDeviceSelect.removeAttribute('disabled');
      }
      listAudioDevices();

      /** @type {HTMLFormElement} */
      const form = document.querySelector('#form');
      /** @type {HTMLButtonElement} */
      const submitButton = document.querySelector('button[type="submit"]');
      /** @type {HTMLButtonElement} */
      const stopButton = document.querySelector('button[type="button"]');
      /** @type {HTMLDivElement} */
      const resultContainer = document.querySelector('#result');
      /** @type {HTMLDivElement} */
      const finalsContainer = document.querySelector('#finals');
      /** @type {HTMLDivElement} */
      const partialsContainer = document.querySelector('#partials');

      form.addEventListener('submit', async (evt) => {
        evt.preventDefault();

        // Parse submitted data
        const formData = new FormData(form);
        const gladiaKey = formData.get('gladia_key');
        const inputDevice = formData.get('input_device');

        // Update the UI
        submitButton.setAttribute('disabled', 'true');
        submitButton.textContent = 'Waiting for connection...';
        resultContainer.style.display = 'none';
        finalsContainer.innerHTML = '';
        partialsContainer.textContent = '...';

        /** @type {MediaStream | undefined} */
        let audioStream;
        /** @type {RecordRTC | undefined} */
        let recorder;
        let liveSession;

        const stop = () => {
          submitButton.removeAttribute('disabled');
          submitButton.style.display = 'block';
          submitButton.textContent = 'Start recording';

          stopButton.setAttribute('disabled', 'true');
          stopButton.style.backgroundColor = '';
          stopButton.style.color = '';
          stopButton.removeEventListener('click', stop);

          recorder?.destroy();
          audioStream?.getTracks().forEach((track) => track.stop());

          if (liveSession) {
            liveSession.endSession();
            liveSession = null;
          }
        };

        try {
          liveSession = new Gladia.GladiaClient({
            apiKey: gladiaKey,
          })
            .liveV2()
            .startSession({
              sample_rate: SAMPLE_RATE,
              messages_config: {
                receive_partial_transcripts: true,
              },
            });

          liveSession.on('message', (message) => {
            if (message.type !== 'transcript') {
              return;
            }

            let prefix = '- ';
            if (message.data.is_final) {
              const div = document.createElement('div');
              div.textContent = `${prefix}${message.data.utterance.text}`;
              finalsContainer.appendChild(div);
              partialsContainer.textContent = '';
            } else {
              partialsContainer.textContent = `${prefix}${message.data.utterance.text}`;
            }
          });
          liveSession.on('error', (error) => {
            const message = `An error occurred: ${error}`;
            window.alert(message);
            console.error(message, error);
          });
          liveSession.on('ended', () => {
            stop();
          });

          // Get the input stream
          audioStream = await navigator.mediaDevices.getUserMedia({
            audio: inputDevice ? { deviceId: { exact: inputDevice } } : true,
          });

          // Initializes the recorder
          recorder = new RecordRTC(audioStream, {
            type: 'audio',
            mimeType: 'audio/wav',
            recorderType: RecordRTC.StereoAudioRecorder,
            timeSlice: 1000,
            async ondataavailable(blob) {
              const buffer = await blob.arrayBuffer();
              // Remove WAV header
              const modifiedBuffer = buffer.slice(44);
              liveSession?.sendAudio(modifiedBuffer);
            },
            desiredSampRate: SAMPLE_RATE,
            numberOfAudioChannels: 1,
          });
        } catch (err) {
          window.alert(
            `Error during the initialization: ${err?.message || err}`,
          );
          console.error(err);
          stop();
          return;
        }

        submitButton.textContent = 'Recording...';

        stopButton.removeAttribute('disabled');
        stopButton.style.backgroundColor = '#d94242';
        stopButton.style.color = '#fff';
        stopButton.addEventListener('click', () => {
          recorder.stopRecording();
          liveSession.stopRecording();
        });

        resultContainer.style.display = 'block';

        // Start the recording
        recorder.startRecording();
      });
    </script>
  </body>
</html>
