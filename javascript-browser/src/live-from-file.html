<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://unpkg.com/@gladiaio/sdk@0.5.1"></script>
    <title>Gladia - Live from file</title>

    <style>
      body {
        margin: 1rem;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      form > div {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      form,
      #result {
        box-sizing: border-box;
        max-width: 500px;
        margin: 0 auto;
      }

      #result {
        margin-top: 1rem;
        border-top: 1px solid #333;
        padding-top: 1rem;
        text-align: justify;
      }
    </style>
  </head>
  <body>
    <form id="form">
      <div>
        <label for="gladia_key">Gladia API key</label>
        <input
          id="gladia_key"
          name="gladia_key"
          type="text"
          placeholder="Gladia API key"
          required
        />
      </div>
      <div>
        <label for="audio">Audio file</label>
        <input
          id="audio"
          name="audio"
          type="file"
          accept="audio/wav, audio/x-wav"
        />
      </div>
      <button type="submit">Start streaming</button>
    </form>

    <div id="result" style="display: none">
      <audio id="audio-player"></audio>
      <div id="finals"></div>
      <div style="color: red" id="partials"></div>
    </div>

    <script>
      async function extractAudioFileData(audio) {
        const textDecoder = new TextDecoder();
        const buffer = await audio.arrayBuffer();
        if (
          textDecoder.decode(buffer.slice(0, 4)) !== 'RIFF' ||
          textDecoder.decode(buffer.slice(8, 12)) !== 'WAVE' ||
          textDecoder.decode(buffer.slice(12, 16)) !== 'fmt '
        ) {
          throw new Error('Unsupported file format');
        }

        const dataview = new DataView(buffer);
        const fmtSize = dataview.getUint32(16, true);
        let encoding;
        const format = dataview.getUint16(20, true);
        if (format === 1) {
          encoding = 'wav/pcm';
        } else if (format === 6) {
          encoding = 'wav/alaw';
        } else if (format === 7) {
          encoding = 'wav/ulaw';
        } else {
          throw new Error('Unsupported encoding');
        }
        const channels = dataview.getUint16(22, true);
        const sample_rate = dataview.getUint32(24, true);
        const bit_depth = dataview.getUint16(34, true);

        let nextSubChunk = 16 + 4 + fmtSize;
        while (
          textDecoder.decode(buffer.slice(nextSubChunk, nextSubChunk + 4)) !==
          'data'
        ) {
          nextSubChunk += 8 + dataview.getUint32(nextSubChunk + 4, true);
        }

        return {
          encoding,
          sample_rate,
          channels,
          bit_depth,
          data: buffer.slice(
            nextSubChunk + 8,
            dataview.getUint32(nextSubChunk + 4, true),
          ),
        };
      }

      /** @type {HTMLFormElement} */
      const form = document.querySelector('#form');
      /** @type {HTMLButtonElement} */
      const submitButton = document.querySelector('button[type="submit"]');
      /** @type {HTMLDivElement} */
      const resultContainer = document.querySelector('#result');
      /** @type {HTMLAudioElement} */
      const audioPlayer = document.querySelector('#audio-player');
      /** @type {HTMLDivElement} */
      const finalsContainer = document.querySelector('#finals');
      /** @type {HTMLDivElement} */
      const partialsContainer = document.querySelector('#partials');

      form.addEventListener('submit', async (evt) => {
        evt.preventDefault();

        // Parse submitted data
        const formData = new FormData(form);
        const gladiaKey = formData.get('gladia_key');
        const audioFile = formData.get('audio');

        // Update the UI
        submitButton.setAttribute('disabled', 'true');
        submitButton.textContent = 'Waiting for connection...';
        resultContainer.style.display = 'none';
        finalsContainer.innerHTML = '';
        partialsContainer.textContent = '...';

        let liveSession;
        let config;
        let audioData;
        let audioSrc = URL.createObjectURL(audioFile);

        const stop = () => {
          audioPlayer.pause();
          audioPlayer.src = '';
          URL.revokeObjectURL(audioSrc);
          audioSrc = null;

          submitButton.removeAttribute('disabled');
          submitButton.style.display = 'block';
          submitButton.textContent = 'Start streaming';

          if (liveSession) {
            liveSession.endSession();
            liveSession = null;
          }
        };

        try {
          const { data, ...rest } = await extractAudioFileData(audioFile);
          audioData = data;
          config = rest;

          liveSession = new Gladia.GladiaClient({
            apiKey: gladiaKey,
          })
            .liveV2()
            .startSession({
              ...config,
              messages_config: {
                receive_partial_transcripts: true,
              },
            });

          liveSession.on('message', (message) => {
            if (message.type !== 'transcript') {
              return;
            }

            let prefix = '- ';
            if (config.channels > 1) {
              prefix = `${message.data.utterance.channel}: `;
            }
            if (message.data.is_final) {
              const div = document.createElement('div');
              div.textContent = `${prefix}${message.data.utterance.text}`;
              finalsContainer.appendChild(div);
              partialsContainer.textContent = '';
            } else {
              partialsContainer.textContent = `${prefix}${message.data.utterance.text}`;
            }
          });
          liveSession.on('error', (error) => {
            const message = `An error occurred: ${error}`;
            window.alert(message);
            console.error(message, error);
          });
          liveSession.on('ended', () => {
            stop();
          });
        } catch (err) {
          window.alert(
            `Error during the initialization: ${err?.message || err}`,
          );
          console.error(err);
          stop();
          return;
        }

        submitButton.textContent = 'Streamingâ€¦';

        resultContainer.style.display = 'block';

        // Start the streaming when audio is ready
        const startPlayback = async () => {
          audioPlayer.play();

          // Send chunk of 50ms
          const chunkDuration = 50;
          const bytesPerSample = config.bit_depth / 8;
          const bytesPerSecond =
            config.sample_rate * config.channels * bytesPerSample;
          const chunkSize = Math.round((chunkDuration / 1000) * bytesPerSecond);
          for (let i = 0; i < audioData.byteLength; i += chunkSize) {
            liveSession.sendAudio(audioData.slice(i, i + chunkSize));
            await new Promise((resolve) => setTimeout(resolve, chunkDuration));
          }
          liveSession.stopRecording();
        };

        audioPlayer.src = audioSrc;
        if (audioPlayer.readyState >= audioPlayer.HAVE_ENOUGH_DATA) {
          startPlayback();
        } else {
          audioPlayer.addEventListener('canplaythrough', startPlayback, {
            once: true,
          });
        }
      });
    </script>
  </body>
</html>
